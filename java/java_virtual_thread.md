## Virtual Threads의 특징

https://velog.io/@dongvelop/JDK-21%EC%9D%B4-%EC%B6%9C%EC%8B%9C%EB%90%98%EC%97%88%EB%8B%A4.-%EC%B5%9C%EC%8B%A0-%EB%AC%B8%EB%B2%95%EC%9D%80-%EC%82%B4%ED%8E%B4%EB%B4%90%EC%95%BC%EC%A7%80#virtual-threads-preview

1. **기존의 플랫폼 스레드 (OS 스레드)와 비교**

- **플랫폼 스레드**는 운영 체제의 스케줄러가 관리하는 실제 OS 수준의 스레드입니다.
    - 이 스레드는 상대적으로 무겁고, 많은 시스템 자원을 차지합니다.
    - 따라서 많은 스레드를 생성하고 관리하는 데 비용이 많이 듭니다.
- **Virtual Threads**는 JVM 수준에서 구현된 경량 스레드로, 운영 체제의 실제 스레드를 사용하지 않고 JVM이 직접 관리
    - 이를 통해 많은 수의 스레드를 보다 효율적으로 생성하고 관리할 수 있습니다.
    - OS 스레드와는 독립적으로 동작하며, 훨씬 적은 리소스를 소비합니다.

<br/>

2. **Virtual Threads의 주요 장점**

- **경량화**: 
  - Virtual Threads는 OS 스레드보다 훨씬 가벼워서, 수천 개 이상의 스레드를 효율적으로 생성하고 관리할 수 있습니다. 
  - 이를 통해 많은 동시 작업을 처리할 수 있습니다.
- **비용 절감**: 
  - OS 스레드보다 메모리 사용량이 적고, 컨텍스트 스위칭과 같은 오버헤드가 낮습니다. 
  - 대규모 애플리케이션에서 동시성 처리 비용을 크게 절감할 수 있습니다.
- **동시성 처리 향상**: 
  - 많은 수의 작업을 동시에 처리할 수 있기 때문에, 특히 **I/O-bound 작업**(네트워크 요청, 파일 시스템 작업 등)에서 큰 성능 향상을 제공합니다. 
  - 예를 들어, 수많은 외부 API 호출을 병렬로 처리할 수 있습니다.
- **간편한 프로그래밍 모델**: 
  - 기존의 `Thread` 클래스를 그대로 사용하되, 스레드 생성과 관리가 매우 간편해졌습니다. 
  - 비동기 코드 대신 동기 코드 스타일로 작성할 수 있어, 코드의 직관성과 유지 보수성이 향상됩니다.

<br/>

3. **제약 사항 및 고려사항**

- **CPU 바운드 작업**: Virtual Threads는 I/O 바운드 작업에서 더 효율적이지만, CPU 바운드 작업에서는 OS 스레드와 유사한 성능을 보입니다. CPU를 많이 사용하는 작업은 여전히 기존의
  플랫폼 스레드를 사용하는 것이 좋습니다.