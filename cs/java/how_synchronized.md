## Synchronized는 어떤 내부 원리로 락을 동작시키는지 설명해주세요.(뮤텍스락)

### synchronized의 내부 원리

- synchronized는 JVM 수준에서 락을 관리하는 동기화 메커니즘
- 객체(Object) 또는 클래스(Class) 단위로 모니터 락(Monitor Lock)을 획득하여 동기화
- 내부적으로 JVM의 모니터(monitor)와 운영체제의 **Mutex(뮤텍스) 락**을 활용

<br/>

### JVM에서 synchronized가 동작하는 원리

synchronized 키워드를 만나면, JVM이 객체의 모니터(Monitor)를 이용하여 락을 관리합니다.

> 모니터(Monitor)란?

- JVM 내부의 객체마다 존재하는 락(lock)
- 특정 스레드가 객체의 모니터를 획득하면, 다른 스레드는 대기해야 함.

<br/>

## 뮤텍스와 세마포어

멀티스레드 환경에서 공유 자원에 대한 접근을 제어하는 대표적인 기법 두 가지

- 뮤텍스(Mutex, Mutual Exclusion Lock) → 1개의 스레드만 접근 가능 (Binary Lock)
- 세마포어(Semaphore) → 여러 개의 스레드가 접근 가능 (Counter 기반 락)

<br/>

### 뮤텍스(Mutex, 상호 배제 락)

- 뮤텍스는 한 번에 오직 하나의 스레드만 공유 자원에 접근할 수 있도록 제한하는 락입니다.
    - 이진 락(Binary Lock) 구조 (0 or 1)
    - 한 스레드가 락을 획득하면 다른 스레드는 무조건 대기해야 함

<br/>

> 뮤텍스 동작 방식

1. Thread A가 락을 획득하고 자원을 사용
2. 다른 Thread B가 접근하려 하면, 락이 해제될 때까지 대기
3. Thread A가 자원 사용을 끝내면 락을 해제
4. Thread B가 락을 획득하고 자원을 사용

- OS 수준에서 커널이 관리하며, synchronized, ReentrantLock 등이 내부적으로 사용함.

<br/>

### 세마포어(Semaphore)

- 세마포어는 "허용 가능한 스레드 개수"를 지정할 수 있는 락
    - 카운터 기반 (N개의 스레드 접근 가능)
    - 0이면 대기, 1 이상이면 접근 가능
    - 운영체제(OS)와 Java Semaphore에서 많이 사용됨

<br/>

> 세마포어 동작 방식

1. 초기 카운터 값이 N(예: 3) 라면, 동시에 최대 3개의 스레드가 접근 가능
2. 새로운 스레드가 접근하면 카운터 감소
3. 스레드가 끝나면 카운터 증가
4. 카운터가 0이 되면 새로운 스레드는 대기 상태

- 뮤텍스는 1개 스레드만 허용하는 세마포어(값이 1인 경우)라고 볼 수 있음!

