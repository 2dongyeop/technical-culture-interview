## Monolithic & MSA

> 모놀리식 장점
>
1. **개발 및 배포가 단순** → 하나의 프로젝트로 관리하기 때문에 개발 및 배포가 쉽다.
2. **한 곳에서 디버깅 가능** → 트랜잭션 흐름이 단순하여 디버깅이 용이하다.
3. **일관된 성능** → 네트워크 통신 오버헤드가 적어 응답 속도가 빠를 수 있다.
4. **운영 비용이 낮음** → 인프라 및 관리 비용이 적게 든다.

<br/>

> 모놀리식 단점
>
1. **서비스 확장이 어렵다** → 특정 모듈만 확장하는 것이 어렵고, 전체 시스템을 확장해야 한다.
2. **배포 시간이 길어짐** → 코드 변경이 발생하면 전체 애플리케이션을 재배포해야 한다.
3. **개발 속도 저하** → 팀이 커질수록 코드 충돌, 빌드 속도 저하 등의 문제가 발생한다.
4. **기술 스택 전환이 어려움** → 일부 기능만 다른 기술을 도입하기 어렵다.

<br/>

> MSA 장점
>
1. **유연한 확장성** → 서비스별로 개별 확장이 가능해 트래픽 처리에 유리하다.
2. **독립적 배포 가능** → 하나의 서비스만 수정 및 배포 가능하여 배포 속도가 향상된다.
3. **기술 스택 선택 가능** → 각 서비스에 맞는 언어나 기술을 선택할 수 있다.
4. **개발 생산성 증가** → 여러 팀이 독립적으로 개발할 수 있어 속도가 향상된다.

<br/>

> MSA 단점
>
1. **운영 복잡성 증가** → 서비스 개수가 증가하면서 인프라, 모니터링, 로깅, 장애 대응이 어려워진다.
2. **네트워크 오버헤드 발생** → 서비스 간 API 통신이 증가하면서 응답 속도가 느려질 수 있다.
3. **데이터 일관성 문제** → 서비스마다 개별 DB를 사용하면 일관성을 유지하는 것이 어렵다.
4. **테스트 및 디버깅 어려움** → 분산된 서비스 환경에서 문제를 추적하기 어려워진다.

<br/>

> 표로 비교
>

| 비교 항목 | Monolithic(모놀리식) | MSA(마이크로서비스) |
| --- | --- | --- |
| **구성 방식** | 하나의 애플리케이션으로 구성 | 독립적인 서비스들의 조합 |
| **배포 방식** | 한 번에 전체 배포 | 서비스 단위로 개별 배포 |
| **확장성** | 수직 확장(Scale-up) 중심 | 수평 확장(Scale-out) 가능 |
| **데이터 저장** | 단일 DB 사용 | 서비스별 개별 DB 사용 가능 |
| **통신 방식** | 내부 메서드 호출 | API, 메시지 큐를 통한 호출 |
| **개발 및 유지보수** | 단일 코드베이스로 관리 | 여러 팀이 독립적으로 개발 가능 |
| **배포 속도** | 변경 시 전체 재배포 필요 | 개별 서비스만 배포 가능 |
| **복잡성** | 비교적 단순한 구조 | 서비스 간 통신, 데이터 일관성 유지 등 고려 필요 |

<br/>

> MSA 전환 시 겪은 주요 이슈와 해결 방법
>
1. 데이터 일관성 문제
    - 각 서비스가 독립적인 DB를 가지게 되면서 **트랜잭션을 ACID 방식으로 보장하기 어려움**.
    - **SAGA 패턴 적용**: 분산 트랜잭션을 보장하기 위해 **보상 트랜잭션을 정의**하여 롤백 처리.
    - **CQRS 패턴 적용**: 서비스 간 데이터 동기화를 위해 Command(Query 모델과 별도 저장소 사용)를 분리.
2. 서비스 간 통신 문제
    - **MSA에서는 HTTP REST API 또는 gRPC 등을 사용**
        - **→** 네트워크 장애, 응답 지연, 요청 실패 등의 문제가 발생할 가능성 증가
    - **비동기 메시징 시스템(Kafka, RabbitMQ) 활용**
        - → 동기 호출보다 비동기 이벤트 방식으로 서비스 간 결합도를 줄임.
    - **Resilience4j를 이용한 서킷 브레이커 적용**
        - → 특정 서비스가 다운될 경우, 장애 전파를 방지하고 빠르게 복구 가능.
3. 인증 및 권한 문제
    - MSA에서는 서비스마다 인증을 처리하면 **중복 코드 증가 및 관리 어려움 발생**.
    - **API Gateway에서 인증 처리**
        - → 서비스마다 인증을 하는 것이 아니라, API Gateway에서 모든 요청을 인증 후 전달.
4. 로그 및 모니터링 문제
    - 서비스가 여러 개로 분리되면서, 장애 발생 시 원인을 추적하기 어려움.
    - **분산 로깅 시스템 적용 (ELK Stack, Loki + Promtail + Grafana)**
    - **분산 트레이싱 적용 (Jaeger, Zipkin, OpenTelemetry)**
        - → 각 요청의 trace ID를 설정하여 서비스 간 호출 흐름을 추적 가능.