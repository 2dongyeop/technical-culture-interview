## Retry 정책을 설계할 때 고려사항

1. **어떤 요청을 재시도할 것인가?**

모든 요청을 재시도하면 안 됨. **재시도가 유효한 요청과 불필요한 요청을 구분**해야 함.

- **재시도가 적절한 경우**
    - **일시적인 네트워크 장애 (Transient Fault)**
        - 네트워크 타임아웃, 일시적인 서버 다운
    - **서버 과부하 (HTTP 429 - Too Many Requests)**
        - 재시도 시 일정 시간 기다렸다가 요청
    - **서버 오류 (HTTP 5xx - Internal Server Error)**
        - 500, 502(Bad Gateway), 503(Service Unavailable), 504(Gateway Timeout)
- **재시도하면 안 되는 경우**
    - **클라이언트 오류 (HTTP 4xx)**
        - 400(Bad Request), 401(Unauthorized), 403(Forbidden), 404(Not Found) → 재시도해도 소용없음
    - **비즈니스 로직에 영향을 주는 요청**
        - **결제 요청, 중복 가입, 주문 생성** 등의 요청은 재시도 시 **중복 처리**될 위험이 있음.
        - 해결책: **Idempotency Key (멱등성 키) 적용**

<br/>

2**재시도 간격(Backoff) 및 최대 재시도 횟수**

- **재시도 간격이 너무 짧으면 서비스 과부하 유발, 너무 길면 응답 속도 저하**
- **무제한 재시도하면 서비스 장애 확산**
- **Exponential Backoff 적용 (지수 백오프)**
    - 재시도 간격을 **점진적으로 늘려서** 서버에 부담을 줄임.
    - 기본적으로 Backoff 나 Hitter 방식을 이용

<br/>

3. **최대 재시도 횟수 설정**

- 재시도를 무한히 하면 안 되므로, **최대 재시도 횟수를 설정**해야 함.
- **일반적인 최대 재시도 횟수 예시**
    - **네트워크 장애**: 3~5회 (Exponential Backoff 적용)
    - **서버 과부하 (429)**: `Retry-After` 헤더 값을 따름
    - **서버 장애 (5xx)**: 3회 이내

<br/>

4. **서킷 브레이커(Circuit Breaker) 적용**

- 장애가 발생한 서비스를 무한히 재시도하면 **장애가 확산**될 수 있음 → **서킷 브레이커 적용**
- 일정 횟수 이상 실패하면 **일정 시간 동안 요청을 차단**하고, 이후 점진적으로 트래픽을 허용.

<br/>

5. **모니터링 및 로깅 필수**

- 재시도 정책을 적용하면 **실제 얼마나 많은 요청이 재시도되는지, 성공률이 어떻게 되는지 모니터링 필요**
- Grafana, Prometheus, ELK(Stack) 등을 사용하여 재시도 로그 분석