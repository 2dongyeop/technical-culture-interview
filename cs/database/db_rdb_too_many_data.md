## RDBMS에서 데이터가 많이 적재되면 무슨 문제가 발생하나요?

> 1. 디스크 I/O 성능 저하

- 디스크 읽기/쓰기가 늘어나면, 데이터베이스가 디스크에서 데이터를 읽고 쓰는 속도가 느려질 수 있음.
    - 특히 디스크 I/O는 상대적으로 느리기 때문에, 데이터가 많을수록 응답 속도가 느려질 수 있음.
- 디스크 공간 부족: 데이터가 많이 적재되면 디스크 공간이 부족해져서 추가적인 디스크 용량 확장이 필요할 수 있다.

<br/>

> 2. 쿼리 성능 저하

- 인덱스 비효율성:
    - 데이터가 많아지면, 인덱스의 크기도 커지기 때문에, 인덱스를 찾는 데 소요되는 시간이 길어질 수 있음.
    - 또한, 잘못 설계된 인덱스는 오히려 성능을 악화시킬 수 있다.
- 조인(JOIN) 연산 비용 증가:
    - 데이터가 많을수록 여러 테이블을 조인하는 쿼리의 성능이 저하될 수 있다.
    - 특히 큰 테이블 간에 조인을 처리할 때 메모리 사용량이 증가하고, 디스크 스와핑이 발생할 수 있다.
- 쿼리 최적화 한계:
    - 대량의 데이터에서 발생하는 복잡한 쿼리는 쿼리 최적화가 잘 이루어지지 않거나, 실행 계획이 비효율적으로 설정되어 성능 저하가 발생할 수 있다.

<br/>

> 3. 데이터베이스 백업과 복구 속도 저하

- 백업:
    - 데이터가 많아지면, 백업 시간이 길어져서 백업 윈도우 내에 백업을 완료하기 어려울 수 있다.
    - 이로 인해 중요한 시스템에서 백업을 자주 수행해야 할 때 성능에 영향을 줄 수 있다.
- 복구:
    - 복구 시간도 늘어나게 되어 장애 복구가 시간이 오래 걸릴 수 있다.
    - 대량의 데이터를 복구하는 데 시간이 많이 걸리면 시스템의 가용성이 낮아질 수 있다.

<br/>

> 4. 메모리 및 CPU 사용량 증가

- 데이터가 많아질수록, 이를 인메모리 캐시나 버퍼 캐시에 저장하려는 시도가 많아지기 때문에 메모리 사용량이 급증할 수 있다.
- 또한, 쿼리 실행 시 CPU 사용량이 증가하고, 서버 자원을 과도하게 사용하게 되어 서버 성능에 악영향을 미칠 수 있다.

<br/>

> 5. 데이터 일관성 유지 어려움

- 트랜잭션 처리:
    - 데이터가 많이 적재되면, 트랜잭션 처리가 더 복잡해지고, 동시에 여러 사용자가 데이터를 다룰 때 동시성 제어가 어려워질 수 있다.
    - 이로 인해 잠금(Lock) 경쟁이 발생하고, 데드락(Deadlock) 상황이 발생할 수 있다.
- 참조 무결성 제약:
    - 외래 키(Foreign Key) 제약이 많은 경우, 데이터가 많아지면 무결성을 유지하는 데 부하가 생길 수 있다.
    - 조인이나 업데이트 작업이 많을수록 성능이 저하될 수 있다.

<br/>

> 6. 데이터베이스 관리의 복잡성 증가

- 데이터베이스 유지보수가 점점 어려워진다.
    - 예를 들어, 대규모 데이터베이스에서는 데이터 청소나 중복 제거 작업이 시간과 비용이 많이 드는 작업이 될 수 있다.
- 파티셔닝(Sharding)이나 분산 시스템을 적용하지 않으면, 대규모 데이터베이스는 성능을 유지하기 어려워질 수 있다.

<br/>

> 7. 데이터베이스의 확장성 문제

- 수직 확장(Vertical Scaling) 방식으로는 한계가 있다.
    - 서버의 CPU, 메모리, 디스크 용량 등을 늘리면 일정 한계에 도달할 수밖에 없기 때문에, 수평 확장(Horizontal Scaling)을 고려해야 하지만, RDBMS는 기본적으로 수평 확장이 어렵거나
      복잡할 수 있어.
- 수평 확장을 하더라도, 데이터 파티셔닝이나 복제 등의 기술이 필요
    - 이를 관리하기 위해 추가적인 복잡성이 발생할 수 있다.

<br/>

> 8. Lock Contention (잠금 경쟁)

- 데이터베이스가 커지면, 동시 사용자가 많아지거나 트랜잭션이 길어질 때 **락(lock)**을 여러 테이블에서 동시에 잡아야 할 수 있다.
- 이때 여러 트랜잭션이 동일한 리소스를 잠그고 대기하는 상황이 발생하면 성능 저하를 일으킬 수 있다.

<br/>

### 해결 방법

> 인덱스 최적화:

- 필요한 인덱스를 적절히 사용하고, 불필요한 인덱스는 제거하여 성능을 최적화할 수 있다.

> 파티셔닝(Sharding):

- 데이터를 여러 서버에 분산하여 저장하는 방법을 사용해 수평 확장을 고려할 수 있다.

> 캐싱:

- 자주 조회되는 데이터를 메모리나 별도의 캐시 서버에 저장해 디스크 I/O를 줄일 수 있다.

> 읽기/쓰기 분리:

- 읽기 성능을 높이기 위해 읽기 전용 복제를 도입하고, 읽기 작업을 여러 슬레이브 서버로 분산시킬 수 있다.

> 쿼리 최적화:

- 쿼리 성능을 높이기 위해 쿼리 리팩토링, 실행 계획 분석, 인덱스 사용 최적화 등의 방법을 적용할 수 있다.

> 분산 데이터베이스:

- 일부 상황에서는 분산 RDBMS 시스템을 고려할 수도 있다 (예: CockroachDB, Google Spanner).
