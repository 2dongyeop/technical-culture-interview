## DB 인덱스가 어떤 자료구조로 이루어져 있어서, 성능을 향상시키나요?

MySQL InnoDB에서 가장 많이 사용하는 인덱스 자료구조는 **B+ 트리 (B+ Tree)**입니다.

<br/>

> **B+ 트리의 특징:**
>

- **균형 트리 구조**로, **데이터가 정렬된 상태로 저장**됨.
- 리프 노드에서 **순차적인 데이터 접근이 가능**하여 **범위 검색(range query)에 최적화**됨.
- **높이가 낮아 탐색 속도가 빠름** (O(log N) 시간 복잡도).
- **내부 노드에는 키 값만 저장하고, 리프 노드에 실제 데이터 저장** → 더 많은 키를 한 노드에 저장 가능.

<br/>

> **그 외 MySQL 인덱스 종류:**
>

- **Hash Index**: 빠른 키-값 조회 가능하지만 범위 검색이 불가능 (MEMORY 엔진에서 사용).
- **Full-Text Index**: 텍스트 검색을 위한 특수한 인덱스 (MATCH() AGAINST() 사용).
- **Spatial Index (R-Tree)**: 지리 정보(GIS 데이터)를 저장할 때 사용.

<br/>

## B+Tree가 검색에 효과적인 이유를 아시나요?

### B+ Tree vs. B-Tree 비교

| 비교 항목         | B-Tree              | B+ Tree                             |
|---------------|---------------------|-------------------------------------|
| **데이터 저장 위치** | 모든 노드에 데이터 저장       | 리프 노드에만 데이터 저장 (내부 노드는 인덱스 역할)      |
| **검색 속도**     | 루트부터 리프까지 탐색        | 내부 노드에서 인덱스 검색 후 리프에서 데이터 찾기 (더 빠름) |
| **순차 검색**     | 중위 순회 필요            | 리프 노드가 Linked List로 연결되어 있어 빠름      |
| **범위 검색**     | 비효율적 (트리 전체 탐색 필요)  | 리프 노드 간 연결로 빠르게 검색 가능               |
| **디스크 I/O**   | 상대적으로 많음            | 인덱스 노드가 많아 I/O가 줄어듦                 |
| **사용 사례**     | 일반적인 트리 구조 (파일 시스템) | 데이터베이스 인덱스, 대용량 데이터 검색 최적화          |

<br/>

### B+Tree 구조 예시

```text
        [30      60]
       /          |         \
 [10  20]   [30  40  50]   [60  70  80]
    |         |           |
[10][20]   [30][40][50]   [60][70][80]  ← 리프 노드 (실제 데이터 저장, Linked List 연결)
```

### B+Tree가 검색에 효과적인 이유

**1. 트리 높이가 낮아서 탐색 속도가 빠름**

- B+Tree는 균형 트리이기 때문에 항상 같은 높이를 유지하여 최악의 경우에도 일정한 탐색 속도를 보장합니다.
- 일반적으로 B+Tree의 차수(Order)가 크기 때문에 깊이가 낮아지고, 검색 시간이 줄어듭니다.

<br/>

**2. 디스크 I/O 최적화 (페이지 단위 접근)**

- 데이터베이스는 메모리가 아닌 디스크(스토리지)에 저장되므로, 디스크 접근(I/O)이 성능의 가장 큰 병목이 됩니다.
- B+Tree는 **한 번에 여러 개의 키를 저장하는 방식(노드 크기 = 페이지 크기)**을 사용하여 디스크 접근 횟수를 최소화합니다.
- 한 번의 디스크 읽기(페이지 접근)로 수십~수백 개의 키를 로드할 수 있어 탐색 속도가 빨라집니다.

<br/>

**3. 리프 노드가 정렬된 상태로 유지 (범위 검색 최적화)**

- 모든 데이터는 리프 노드에만 저장되며, 리프 노드들은 Linked List로 연결되어 있습니다.
- 따라서 범위 검색(RANGE SCAN)이 매우 빠릅니다.
- 예를 들어, SELECT * FROM users WHERE age BETWEEN 20 AND 30; 같은 범위 검색 쿼리는 한 번 찾은 위치에서 Linked List를 따라가면서 순차적으로 데이터를 가져올 수
  있어 속도가 빠릅니다.


  