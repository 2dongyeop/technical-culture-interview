## 문자 전송 성능이 200ms → 9ms로 개선된 과정은 어떻게 이루어졌나요?

> **기존 방식 (OpenFeign + @Async, 200ms 소요)**
>

- OpenFeign을 사용하여 문자 전송 API를 호출하는 코드에서 `@Async`를 적용하여 비동기 호출을 시도
- 그러나, `@Async`는 Spring의 단순한 비동기 처리 방식으로, 내부적으로 **스레드 풀을 활용하여 요청을 병렬 처리하는 방식이기 때문에 완전한 논블로킹 환경이 아님.**
- 요청량이 증가할 경우 스레드 풀의 크기에 따라 **스레드 컨텍스트 스위칭 오버헤드가 발생**하며, 추가적인 성능 최적화가 어려움.

<br/>

> **개선 방식 (Reactive Feign 적용, 9ms로 단축)**
>

- OpenFeign 대신 **Reactive Feign**을 적용하여 문자 전송 API 호출을 **완전한 논블로킹 방식으로 처리**
- Reactive Feign은 내부적으로 Spring WebFlux 기반의 Reactor 패턴(Mono/Flux)을 사용하여 백프레셔(Backpressure) 지원 및 비동기 논블로킹 방식으로 요청을 처리함.
- 이를 통해 **스레드 풀을 유지할 필요 없이 단일 스레드에서 효율적으로 병렬 요청을 처리**할 수 있었음.
- 결과적으로 문자 전송 시간이 **9ms로 대폭 단축**됨.

<br/>

> 답변 예시
>

- *기존에는 OpenFeign을 사용하여 문자 전송 API를 호출했으며, @Async를 적용하여 비동기화를 시도했지만, 내부적으로 스레드 풀을 사용하기 때문에 네트워크 I/O 대기로 인해 200ms 정도의 시간이
  소요되었습니다.*
- *이를 해결하기 위해 Reactive Feign을 적용하였고, Spring WebFlux 기반의 논블로킹 방식으로 변경하여 요청을 병렬 처리했습니다.*
- *이 과정에서 스레드 컨텍스트 스위칭을 제거하고 네트워크 I/O 대기 시간을 최소화하여, 최종적으로 문자 전송 시간이 9ms로 단축되었습니다."*